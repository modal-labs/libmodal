package modal

import (
	"math"
	"math/big"
	"testing"

	pickle "github.com/kisielk/og-rek"
	"github.com/onsi/gomega"
)

// Golden bytes generated by Python's cloudpickle.dumps(value, protocol=4).
// These are the canonical byte sequences that the Modal Dict server expects.

var goldenCases = []struct {
	name  string
	value any
	bytes []byte
}{
	{"nil", nil, []byte{0x80, 0x04, 0x4e, 0x2e}},
	{"true", true, []byte{0x80, 0x04, 0x88, 0x2e}},
	{"false", false, []byte{0x80, 0x04, 0x89, 0x2e}},
	{"int 0", 0, []byte{0x80, 0x04, 0x4b, 0x00, 0x2e}},
	{"int 1", 1, []byte{0x80, 0x04, 0x4b, 0x01, 0x2e}},
	{"int 42", 42, []byte{0x80, 0x04, 0x4b, 0x2a, 0x2e}},
	{"int 255", 255, []byte{0x80, 0x04, 0x4b, 0xff, 0x2e}},
	{"int 256", 256, []byte{0x80, 0x04, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x01, 0x2e}},
	{"int 65535", 65535, []byte{0x80, 0x04, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0xff, 0xff, 0x2e}},
	{"int 65536", 65536, []byte{0x80, 0x04, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x01, 0x00, 0x2e}},
	{"int -1", -1, []byte{0x80, 0x04, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0xff, 0xff, 0xff, 0xff, 0x2e}},
	{"int -100", -100, []byte{0x80, 0x04, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x9c, 0xff, 0xff, 0xff, 0x2e}},
	{"int MaxInt32", int64(math.MaxInt32), []byte{0x80, 0x04, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0xff, 0xff, 0xff, 0x7f, 0x2e}},
	{"int MinInt32", int64(math.MinInt32), []byte{0x80, 0x04, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x80, 0x2e}},
	{"int MaxInt32+1", int64(math.MaxInt32) + 1, []byte{0x80, 0x04, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x05, 0x00, 0x00, 0x00, 0x80, 0x00, 0x2e}},
	{"int MinInt32-1", int64(math.MinInt32) - 1, []byte{0x80, 0x04, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x05, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x2e}},
	{"int MaxInt64", int64(math.MaxInt64), []byte{0x80, 0x04, 0x95, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x2e}},
	{"int MinInt64", int64(math.MinInt64), []byte{0x80, 0x04, 0x95, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e}},
	{"uint MaxUint64", uint64(math.MaxUint64), []byte{0x80, 0x04, 0x95, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x2e}},
	{"float 1.5", 1.5, []byte{0x80, 0x04, 0x95, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e}},
	{"float 3.14", 3.14, []byte{0x80, 0x04, 0x95, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x40, 0x09, 0x1e, 0xb8, 0x51, 0xeb, 0x85, 0x1f, 0x2e}},
	{"string hello", "hello", []byte{0x80, 0x04, 0x95, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x94, 0x2e}},
	{"string empty", "", []byte{0x80, 0x04, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x94, 0x2e}},
	{"bytes short", []byte("hello bytes"), []byte{0x80, 0x04, 0x95, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x94, 0x2e}},
	{"bytes empty", []byte{}, []byte{0x80, 0x04, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x94, 0x2e}},
}

// TestDictSerializeKeyGoldenBytes verifies Go → Python compatibility:
// dictSerializeKey produces bytes identical to Python's cloudpickle.dumps(value, protocol=4).
func TestDictSerializeKeyGoldenBytes(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	for _, tc := range goldenCases {
		t.Run(tc.name, func(t *testing.T) {
			got, err := dictSerializeKey(tc.value)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())
			g.Expect(got).To(gomega.Equal(tc.bytes), "dictSerializeKey(%v) bytes mismatch", tc.value)
		})
	}
}

// TestDictDeserializeCloudpickleBytes verifies Python → Go compatibility:
// cloudpickle bytes can be deserialized correctly by og-rek's decoder.
func TestDictDeserializeCloudpickleBytes(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	// og-rek decodes Python ints as int64, floats as float64.
	// For ints beyond int64 range (e.g. MaxUint64), og-rek returns *big.Int.
	// og-rek decodes None as pickle.None{}, not Go nil.
	expected := map[string]any{
		"nil":            pickle.None{},
		"true":           true,
		"false":          false,
		"int 0":          int64(0),
		"int 1":          int64(1),
		"int 42":         int64(42),
		"int 255":        int64(255),
		"int 256":        int64(256),
		"int 65535":      int64(65535),
		"int 65536":      int64(65536),
		"int -1":         int64(-1),
		"int -100":       int64(-100),
		"int MaxInt32":   int64(math.MaxInt32),
		"int MinInt32":   int64(math.MinInt32),
		"int MaxInt32+1": new(big.Int).SetInt64(int64(math.MaxInt32) + 1),
		"int MinInt32-1": new(big.Int).SetInt64(int64(math.MinInt32) - 1),
		"int MaxInt64":   new(big.Int).SetInt64(math.MaxInt64),
		"int MinInt64":   new(big.Int).SetInt64(math.MinInt64),
		"uint MaxUint64": new(big.Int).SetUint64(math.MaxUint64),
		"float 1.5":      float64(1.5),
		"float 3.14":     float64(3.14),
		"string hello":   "hello",
		"string empty":   "",
		"bytes short":    pickle.Bytes("hello bytes"),
		"bytes empty":    pickle.Bytes(""),
	}

	for _, tc := range goldenCases {
		exp, ok := expected[tc.name]
		if !ok {
			continue
		}
		t.Run(tc.name, func(t *testing.T) {
			got, err := pickleDeserialize(tc.bytes)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())
			g.Expect(got).To(gomega.Equal(exp), "pickleDeserialize(%s) value mismatch", tc.name)
		})
	}
}

// TestDictSerializeKeyRoundTrip verifies Go → Go compatibility:
// serialize with dictSerializeKey, then deserialize with pickleDeserialize.
func TestDictSerializeKeyRoundTrip(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	cases := []struct {
		name  string
		input any
		want  any // expected value after round-trip (may differ due to type widening)
	}{
		{"nil", nil, pickle.None{}},
		{"true", true, true},
		{"false", false, false},
		{"int 0", 0, int64(0)},
		{"int 42", 42, int64(42)},
		{"int -100", -100, int64(-100)},
		{"int MaxInt32", int64(math.MaxInt32), int64(math.MaxInt32)},
		{"int MinInt32", int64(math.MinInt32), int64(math.MinInt32)},
		{"int MaxInt32+1", int64(math.MaxInt32) + 1, new(big.Int).SetInt64(int64(math.MaxInt32) + 1)},
		{"int MinInt32-1", int64(math.MinInt32) - 1, new(big.Int).SetInt64(int64(math.MinInt32) - 1)},
		{"int MaxInt64", int64(math.MaxInt64), new(big.Int).SetInt64(math.MaxInt64)},
		{"int MinInt64", int64(math.MinInt64), new(big.Int).SetInt64(math.MinInt64)},
		{"uint MaxUint64", uint64(math.MaxUint64), new(big.Int).SetUint64(math.MaxUint64)},
		{"int8", int8(127), int64(127)},
		{"int16", int16(32000), int64(32000)},
		{"int32", int32(math.MaxInt32), int64(math.MaxInt32)},
		{"uint8", uint8(200), int64(200)},
		{"uint16", uint16(50000), int64(50000)},
		{"uint32", uint32(math.MaxUint32), new(big.Int).SetInt64(int64(math.MaxUint32))},
		{"float64", 3.14, float64(3.14)},
		{"float32", float32(1.5), float64(1.5)},
		{"string", "hello world", "hello world"},
		{"string empty", "", ""},
		{"bytes", []byte{1, 2, 3}, pickle.Bytes(string([]byte{1, 2, 3}))},
		{"bytes empty", []byte{}, pickle.Bytes("")},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			serialized, err := dictSerializeKey(tc.input)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())

			deserialized, err := pickleDeserialize(serialized)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())
			g.Expect(deserialized).To(gomega.Equal(tc.want), "round-trip mismatch for %s", tc.name)
		})
	}
}

// TestOgrekCloudpickleTransformRoundTrip verifies that cloudpickleToOgRek
// is the inverse of ogrekToCloudpickle for all supported types.
func TestOgrekCloudpickleTransformRoundTrip(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	values := []any{
		nil, true, false,
		0, 42, -1, 255, 256, 65535, 65536, -100,
		int64(math.MaxInt32), int64(math.MinInt32),
		int64(math.MaxInt32) + 1, int64(math.MinInt32) - 1,
		int64(math.MaxInt64), int64(math.MinInt64),
		uint64(math.MaxUint64),
		1.5, 3.14,
		"hello", "",
		[]byte{1, 2, 3}, []byte{},
	}

	for _, v := range values {
		raw, err := dictOgRekP4Serialize(v)
		g.Expect(err).ShouldNot(gomega.HaveOccurred())

		patched := ogrekToCloudpickle(raw)
		stripped := cloudpickleToOgRek(patched)

		g.Expect(stripped).To(gomega.Equal(raw), "round-trip transform mismatch for %v", v)
	}
}
